правильный с точки зрения задания код декью, но дающий неккоректные результаты код

#include "utils.h"
#include <deque>
#include <benchmark/benchmark.h>

std::deque<int> generatedata(size_t n) {
std::deque<int> deq;
for (size_t i = 0; i < n; i++)
deq.push_back(static_cast<int>(i));
return deq;
}

void benchmark_pushback(benchmark::State& state) {
auto N = state.range(0);
for (auto _ : state) {
auto deq = generatedata(N);
benchmark::DoNotOptimize(deq);
deq.push_back(77);
state.counters["size"] = static_cast<double>(deq.size());
benchmark::ClobberMemory();
}
}

void benchmark_pushfront(benchmark::State& state) {
auto N = state.range(0);
for (auto _ : state) {
auto deq = generatedata(N);
benchmark::DoNotOptimize(deq);
deq.push_front(77);
state.counters["size"] = static_cast<double>(deq.size());
benchmark::ClobberMemory();
}
}

void benchmark_randominsert(benchmark::State& state) {
auto N = state.range(0);
for (auto _ : state) {
auto deq = generatedata(N);
deq.insert(deq.begin() + 9, 77);
state.counters["size"] = static_cast<double>(deq.size());
benchmark::DoNotOptimize(deq);
benchmark::ClobberMemory();
}
}

void benchmark_randomerase(benchmark::State& state) {
auto N = state.range(0);
for (auto _ : state) {
auto deq = generatedata(N);
if (deq.size() > 9) deq.erase(deq.begin() + 9);
state.counters["size"] = static_cast<double>(deq.size());
benchmark::DoNotOptimize(deq);
benchmark::ClobberMemory();
}
}

void benchmark_randomaccess(benchmark::State& state) {
auto N = state.range(0);
for (auto _ : state) {
auto deq = generatedata(N);
if (deq.size() > 9) {
benchmark::DoNotOptimize(deq[9]);
deq[9] = 666;
}
state.counters["size"] = static_cast<double>(deq.size());
benchmark::ClobberMemory();
}
}

выводы в результатах: 
сначала вывод правилного по заданию кода, потом актуального, показывающего разницу в дороговизне операций


1. Почему у std: : deque нет метода capacity()? Как устроен deque внутри, покажите схемой (рисунком)? Как в нем осуществляется ин-дексация и добавление элементов?

deque это автоматизированный зубчатый массив(структурно), 
декью хранит много маленьких блоков и массив указателей на них 
┌───┬───┬───┐
│ B │ B │ B │ каждый B это блок фикс размера
└───┴───┴───┘
каждый новый блок требует нового указателя в map
чтобы найти элемент в декью, нужно перейти по индексу блока, а потом по индексу внутри того блока где лежит элемент
(обычно чуть медленнее чем у вектора из-за двойной индексации)
если добавляем элемент, то сначала пытаемся его добавить в блок, где есть свободное место, если в конце/начале нет свободных блоков,
то создаем новый и добавляем указатель на него в map(в начало или конец)

схема

+----+----+----+----+
| B0 | B1 | B2 | B3 |
+----+----+----+----+
^    ^    ^    ^
|    |    |    |
e0   e4   e8   e12
e1   e5   e9   e13
e2   e6  e10   e14
e3   e7  e11   e15

Чтобы получить декью[5]:
(start_index + 5) / размер блока = (1+5)/4 = 1 → B1
(start_index + 5) % размер блока = 6 % 4 = 2 → элемент e6

!элементы декью не должны храниться подряд в памяти и сами блоки могут быть раскиданы в памяти(в отлиие от вектора)

2. Как изменяется время выполнения для каждой операции при увеличении N? Какая асимптотическая сложность у каждой операции (тео-ретически и по вашим замерам)?

push_back - теоретическая сложность О(1) 
по моим замерам видно, что время почти константное при увеличении объема
так происходит, потому что при добавлении элемента могут быть только локальные очень незначительнве сдвиги, которые глобально 
не имеют значения. также в данной структуре данные добавляются просто в конец блока/создается новый и нет необходимости сдвигать всю структуру

push_front - теоретическая сожность О(1)
время почти не растет с увеличением массива, так как добавление происходит в свободное место в 1 блоке или через создание нового
блока и добавления указателя на него. 
при больших массивах указателей могут появляться издержки времени на кеширование указателей

erase(pos) - теоретическая сложность О(n)
время не меняется от увеличения количества, так как все операции происходят в блоках фиксированных размеров 
может потребоваться удалить пустой блок и обновить массив указателей что незначительно влияет на время
время тратиться на сдвиг n элементов в пределах блока, в котором был удален элемент

insert(pos) - теоретическая сложность О(N)
по моим замерам время растет незначительно 
так происходит потому что все зависит только от размера блока и колчиесвта элементов в нем, то есть при вставке мы
можем 1 создать новый блок и передвинуть в него элементы из блока куда была произведена вставка(викс количество элементов)
2 сдвинуть какое-то количество элементов внутри блока 3 обновить указатели
также O(N) это худший случай, когда нужно двигать элементы между блоками, когда их нужно двигать только в самом блоке, то операция "дешевле"


random access []
теоретическая сложность O(N)
по моим замерам время почти не меняется от увеличения размера массива
время тратится только на вычисление индекса блока, а потом на вычисление индекса внутри блока



3. Сравните производительность deque и vector (из задания 1) для операций PushFront и RandomAccess. Объясните различия.

pushfront у вектора требует сдвига всего массива вправо, при этом все элементы хранятся подряд, поэтому невозможно оптимизировать
у декью стурктура похожа на зубчатый массив и нужно либо найти свободное место в блоке фикс размера либо создать новый - 
нет необходимости двигать весь массив; особенно это видно при увеличении данных
у вектора время прямо зависит от n и удваивается, а у декью оно константно

randomaccess у вектора это асимптотика O(1)
элементы хранятся непрерывно, адрес вычиляется как начало массива + i*sizeof
у декью такая же асимтотика, но мы сначала обращаемся к индексу блока а потом к индексу внутри него 
это требует дополнительных вычислений и обращений к памяти 
время константно и там и там, но у декью чуть больше

4. Почему deque эффективен для вставки/удаления в начало, но медленнее vector при случайном доступе?

декью эффективнее для вставки и удаления так как хранит элементы по блокам и не требует сдвигов всего массива
вектор должен хранить элементы непрерывно в одном масиве из-за чего при вставках и удалениях нужно сдвинуть весь массив

при случайном доступе вектор быстрее так как индекс используется напрямую через одну операцию, а в декью нужно два шага(до блока и внутри блока)

5. В каких сценариях предпочтительно использовать deque вместо
   vector?

в операциях удаления или вставки, особенно в начало, либо одноврменно в начало и конец 
декью стоит использовать также когда размер массива непредсказуемо меняется и необходимо перевыделение памяти(в случае использования вектора)
также стоит использовать декью когда нам нужна стабильность ссылок, так как в векторе при сдвигах ссылки становятся недействительными(у декью только на элементы внутри блока, а не на весь массив)

6. Может ли deque хранить элементы в непрерывной области памяти?
   Зачем так сделано?

блоки могут случайно оказаться рядом в памяти, но это не гарантируется и не обязательно, deque не имеет критерия непрерывности
так сделано для оптимизации вставок или удалений, потому что декью это массив блоков, которые могут быть полностью или частивно заполнены, но не требуют 
перевыделения памяти и копирования при увеличении количества элементов
декью сделан для гибкой реализации операций с предполагаемым сдвигом но не для оптимизации случайного доступа

7. Какие операции у deque имеют сложность O(1), а какие О(n)?

операции O(N) : insert, erase, clear, clear, resize - нужно перемещать элементы внутри одного или нескольких блоков и иногда изенять укаатели на блоки
у insert и erase время может идти к О(b) так как перемещения могут быть локальными в пределах 1 блока
операции О(1) : push_back push_front , pop_back, pop_front, front, back - нужно обратиться к элементам в крайних блоках, 
либо пользоваться арифметикой индексов без потребности в сдвигах в блоках